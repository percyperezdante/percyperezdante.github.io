---
title: "Go"
date: 2020-05-11T11:04:57+01:00
---

#### References
The following notes were extracted, adjusted or extended from the following references.

- [Go mastering by Mihalis Tsoukalos](https://www.packtpub.com/networking-and-servers/mastering-go)


### General

**1. Go inserts only a semicolon at the end of a "{"**

```bash
 func main()
 {              // <-- this will trigger error
    ....
 }
```

```bash
 func main(){              // <-- this will  NOT trigger error
    ....
 }
```

**2. Install and clean packages**

```bash
$ go get -v github.com/mastsoud/go/package_name
.....
$ go clean -i -v -x package_name
$ rm -rf ~/go/src/github.com/mastsoud/go/package_name

```

**3. Stdin/out/err**

| Go       | Unix                                             |
|----------|--------------------------------------------------|
|os.Stdin  |  stdin   -->  /dev/stdin  -->  /proc/self/fd/0   | 
|os.Stdout | stdout   -->  /dev/stdout  -->  /proc/self/fd/1  | 
|os.Stderr | stderr   -->  /dev/stderr  -->  /proc/self/fd/2  | 


**4. Reading input**

```bash
package main
import (
    "bufio"
    "fmt"
    "os"
)

func main(){
    var f *os.File
    f = os.Stdin
    defer f.Close()
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        fmt.Println(">", scanner.Text())
    }
}
```

**5. Logs**

- rsyslogd configuration

```bash
$ grep -v "#" /etc/rsyslog.conf
```

- Syslog

```bash
package main
import (
    "fmt"
    "log"
    "log/syslog"
    "os"
    "path/filepath"
)
func main() {
    programName := filepath.Base(os.Args[0])
    sysLog, err := syslog.New(syslog.LOG_INFO|syslog.LOG_LOCAL7,programName)
    if err != nil {
        log.Fatal(err)
    } else {
        log.SetOutput(sysLog)
    }
    log.Println("LOG_INFO + LOG_LOCAL7: Logging in Go!")
    sysLog, err = syslog.New(syslog.LOG_MAIL, "Some program!")
    if err != nil {
        log.Fatal(err)
    } else {
        log.SetOutput(sysLog)
    }
    log.Println("LOG_MAIL: Logging in Go!")
    fmt.Println("Will you see this?")
}

```

**6. Errors**

- Error types

```bash
package main
import (
    "errors"
    "fmt"
)
func returnError(a, b int) error {
    if a == b {
        err := errors.New("Error in returnError() function!")
        return err
    } else {
        return nil
    }
}

func main() {
    err := returnError(1, 2)
    if err == nil {
    fmt.Println("returnError() ended normally!")
        fmt.Println(err)
    }
    err = returnError(10, 10)
    if err == nil {
        fmt.Println("returnError() ended normally!")
    } else {
        fmt.Println(err)
    }
    if err.Error() == "Error in returnError() function!" {
        fmt.Println("!!")
    }
}

```

- Typical handling of errors

```bash
   if err != nil {
        fmt.Println(err)  or  log.Println(err)    or   panic(err)
        os.Exit(10)
    } 
```

- Example

```bash
package main
import (
    "errors"
    "fmt"
    "os"
    "strconv"
)
func main() {
    if len(os.Args) == 1 {
        fmt.Println("Please give one or more floats.")
        os.Exit(1)
    }
    arguments := os.Args
    var err error = errors.New("An error")
    k := 1
    var n float64
    for err != nil {
        if k >= len(arguments) {
            fmt.Println("None of the arguments is a float!")
            return
        }
        n, err = strconv.ParseFloat(arguments[k], 64)
        k++
    }
    min, max := n, n
    for i := 2; i < len(arguments); i++ {
        n, err := strconv.ParseFloat(arguments[i], 64)
        if err == nil {
            if n < min {
                min = n
            }
            if n > max {
                max = n
            }
        }
    }
    fmt.Println("Min:", min)
    fmt.Println("Max:", max)
}

```

**7. Using docker**

- Dockerfile

```bash
FROM golang:alpine
RUN mkdir /files
COPY hw.go /files
WORKDIR /file
RUN go build -o /files/hw hw.go
ENTRYPOINT ["/files/hw"]
```

```bash
$ docker build -t go_hw:v1 .
$ docker run go_hw:v1
```

### Go internals

**1. Go compiler**

- Compiling source file and generate Object code.

```bash
$ go tool compile sourceFile.go
$ ls -ltr sourceFile.o  # This is not executable.
```

- Genereate an object file instaed of object code

```bash
$ go tool compile -pack sourceFile.go
$ ls -ltr sourceFile.a  
```

- The following will list the content of *.a file.

```bash
$ ar t sourceFile.a
__.PKGDEF
_go_.o

```

- To detect trace conditions

```bash
$ go tool compile -race sourceFile.a
```

- Showing assembly code

```bash
$ go tool compile -S sourceFile.go

os.(*File).close STEXT dupok nosplit size=26 args=0x18 locals=0x0
	0x0000 00000 (<autogenerated>:1)	TEXT	os.(*File).close(SB), DUPOK|NOSPLIT|ABIInternal, $0-24
	0x0000 00000 (<autogenerated>:1)	PCDATA	$0, $-2
	0x0000 00000 (<autogenerated>:1)	PCDATA	$1, $-2
	0x0000 00000 (<autogenerated>:1)	FUNCDATA	$0, gclocals·e6397a44f8e1b6e77d0f200b4fba5269(SB)
	0x0000 00000 (<autogenerated>:1)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0000 00000 (<autogenerated>:1)	FUNCDATA	$2, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)
	0x0000 00000 (<autogenerated>:1)	PCDATA	$0, $1
	0x0000 00000 (<autogenerated>:1)	PCDATA	$1, $1
	0x0000 00000 (<autogenerated>:1)	MOVQ	""..this+8(SP), AX
	0x0005 00005 (<autogenerated>:1)	MOVQ	(AX), AX
	0x0008 00008 (<autogenerated>:1)	PCDATA	$0, $0
	0x0008 00008 (<autogenerated>:1)	PCDATA	$1, $0
	0x0008 00008 (<autogenerated>:1)	MOVQ	AX, ""..this+8(SP)
	0x000d 00013 (<autogenerated>:1)	XORPS	X0, X0

...
```

**2. Garbage collector**

- Example of GC

```bash
package main
import (
    "fmt"
    "runtime"
    "time"
)
func printStats(mem runtime.MemStats) {
    runtime.ReadMemStats(&mem)
    fmt.Println("mem.Alloc:", mem.Alloc)
    fmt.Println("mem.TotalAlloc:", mem.TotalAlloc)
    fmt.Println("mem.HeapAlloc:", mem.HeapAlloc)
    fmt.Println("mem.NumGC:", mem.NumGC)
    fmt.Println("-----")
}

func main() {
    var mem runtime.MemStats
    printStats(mem)
    for i := 0; i < 10; i++ {
        s := make([]byte, 50000000) // memory allocation
        if s == nil {
            fmt.Println("Operation failed!")
        }
    }
    printStats(mem)
    for i := 0; i < 10; i++ {
        s := make([]byte, 100000000) // MORE memory allocation
        if s == nil {
            fmt.Println("Operation failed!")
        }
        time.Sleep(5 * time.Second)
    }
    printStats(mem)
}

```

```bash
$ go run gColl.go
```

- To get MORE information 

```bash
$ GODEBUG=gctrace=1 go run gColl.go

gc 1 @0.027s 0%: 0.048+0.72+0.007 ms clock, 0.38+0.18/0.62/1.1+0.057 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 2 @0.047s 0%: 0.006+0.56+0.007 ms clock, 0.055+0.39/0.69/0.79+0.061 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 3 @0.060s 1%: 0.16+1.0+0.011 ms clock, 1.2+1.3/1.1/0.13+0.093 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 4 @0.069s 1%: 0.016+0.54+0.016 ms clock, 0.13+0.16/0.61/1.0+0.12 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 5 @0.073s 1%: 0.002+0.37+0.003 ms clock, 0.023+0/0.37/1.0+0.028 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 6 @0.076s 1%: 0.016+0.41+0.011 ms clock, 0.13+0.14/0.60/0.40+0.088 ms cpu, 4->4->1 MB, 5 MB goal, 8 P
gc 7 @0.079s 1%: 0.002+0.34+0.010 ms clock, 0.020+0.14/0.36/0.82+0.081 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
# command-line-arguments
gc 1 @0.001s 10%: 0.002+1.3+0.011 ms clock, 0.018+0.82/1.4/2.0+0.092 ms cpu, 5->6->6 MB, 6 MB goal, 8 P
gc 2 @0.010s 7%: 0.004+3.4+0.011 ms clock, 0.036+0.42/5.3/3.8+0.090 ms cpu, 13->14->13 MB, 14 MB goal, 8 P
gc 3 @0.044s 4%: 0.017+4.8+0.011 ms clock, 0.13+0.18/8.2/18+0.093 ms cpu, 25->25->23 MB, 26 MB goal, 8 P
mem.Alloc: 125896

```

Taking the example of "4->4->0": 

        - The first number is the heap size when the garbage collector is about to run. 
        - The second value is the heap size when the garbage collector ends its operation. 
        - The last value is the size of the live heap

**3. GC internals**


**GC in slices**

**GC in maps**

**GC in maps without pointers**

**GC in spliting maps**

**GC comparisons`**

**GC unsafe code**

**GC unsafe package**

**Defer keyword**

**Defer keyword using logging**

**Panic**

**Recover**


**Strace**

**dtrace**

**Go environment**

**Node trees**

**Go build**

**WebAssembly code**


### Data types

**1. Slices**

- Slices are passed by reference to functions.

- Slices are often used, more than arrays.

```bash
 mySlcie := []int{1,23,4}
 mySlice := make([]int, 20)  // Go initilise with default values
 mySlice = append(mySlice, 2134)
 len(mySlice)
 fmt.Println(mySlice[1:3])
```

- Re-slicing may cause some problems.

Reslice do not copy values, reslice keeps reference from the orignal slice. Therefore, if you make any change of values in the reslice, they will also change values in the original slice.


```bash
package main
import "fmt"
func main() {
    s1 := make([]int, 5)
    reSlice := s1[1:3]  // Reslice not copy from s1, it make reference
    fmt.Println(s1)
    fmt.Println(reSlice)
    reSlice[0] = -100  // This means also s[1]=-100
    reSlice[1] = 123456 // This also means s[2]=123456
    fmt.Println(s1)
    fmt.Println(reSlice)
}

```

Output
```
$ go run reslice.go
[0 0 0 0 0]
[0 0]
[0 -100 123456 0 0]
[-100 123456]
```

