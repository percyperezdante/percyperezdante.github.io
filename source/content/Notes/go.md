---
title: "Go"
date: 2020-05-11T11:04:57+01:00
---

#### References
The following notes were extracted, adjusted or extended from the following references.

- [Go mastering by Mihalis Tsoukalos](https://www.packtpub.com/networking-and-servers/mastering-go)


### General

**1. Go inserts only a semicolon at the end of a "{"**

```bash
 func main()
 {              // <-- this will trigger error
    ....
 }
```

```bash
 func main(){              // <-- this will  NOT trigger error
    ....
 }
```

**2. Install and clean packages**

```bash
$ go get -v github.com/mastsoud/go/package_name
.....
$ go clean -i -v -x package_name
$ rm -rf ~/go/src/github.com/mastsoud/go/package_name

```

**3. Stdin/out/err**

| Go       | Unix                                             |
|----------|--------------------------------------------------|
|os.Stdin  |  stdin   -->  /dev/stdin  -->  /proc/self/fd/0   | 
|os.Stdout | stdout   -->  /dev/stdout  -->  /proc/self/fd/1  | 
|os.Stderr | stderr   -->  /dev/stderr  -->  /proc/self/fd/2  | 


**4. Reading input**

```bash
package main
import (
    "bufio"
    "fmt"
    "os"
)

func main(){
    var f *os.File
    f = os.Stdin
    defer f.Close()
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        fmt.Println(">", scanner.Text())
    }
}
```

**5. Logs**

- rsyslogd configuration

```bash
$ grep -v "#" /etc/rsyslog.conf
```

- Syslog

```bash
package main
import (
    "fmt"
    "log"
    "log/syslog"
    "os"
    "path/filepath"
)
func main() {
    programName := filepath.Base(os.Args[0])
    sysLog, err := syslog.New(syslog.LOG_INFO|syslog.LOG_LOCAL7,programName)
    if err != nil {
        log.Fatal(err)
    } else {
        log.SetOutput(sysLog)
    }
    log.Println("LOG_INFO + LOG_LOCAL7: Logging in Go!")
    sysLog, err = syslog.New(syslog.LOG_MAIL, "Some program!")
    if err != nil {
        log.Fatal(err)
    } else {
        log.SetOutput(sysLog)
    }
    log.Println("LOG_MAIL: Logging in Go!")
    fmt.Println("Will you see this?")
}

```

**6. Errors**

- Error types

```bash
package main
import (
    "errors"
    "fmt"
)
func returnError(a, b int) error {
    if a == b {
        err := errors.New("Error in returnError() function!")
        return err
    } else {
        return nil
    }
}

func main() {
    err := returnError(1, 2)
    if err == nil {
    fmt.Println("returnError() ended normally!")
        fmt.Println(err)
    }
    err = returnError(10, 10)
    if err == nil {
        fmt.Println("returnError() ended normally!")
    } else {
        fmt.Println(err)
    }
    if err.Error() == "Error in returnError() function!" {
        fmt.Println("!!")
    }
}

```

- Typical handling of errors

```bash
   if err != nil {
        fmt.Println(err)  or  log.Println(err)    or   panic(err)
        os.Exit(10)
    } 
```

- Example

```bash
package main
import (
    "errors"
    "fmt"
    "os"
    "strconv"
)
func main() {
    if len(os.Args) == 1 {
        fmt.Println("Please give one or more floats.")
        os.Exit(1)
    }
    arguments := os.Args
    var err error = errors.New("An error")
    k := 1
    var n float64
    for err != nil {
        if k >= len(arguments) {
            fmt.Println("None of the arguments is a float!")
            return
        }
        n, err = strconv.ParseFloat(arguments[k], 64)
        k++
    }
    min, max := n, n
    for i := 2; i < len(arguments); i++ {
        n, err := strconv.ParseFloat(arguments[i], 64)
        if err == nil {
            if n < min {
                min = n
            }
            if n > max {
                max = n
            }
        }
    }
    fmt.Println("Min:", min)
    fmt.Println("Max:", max)
}

```

**7. Using docker**

- Dockerfile

```bash
FROM golang:alpine
RUN mkdir /files
COPY hw.go /files
WORKDIR /file
RUN go build -o /files/hw hw.go
ENTRYPOINT ["/files/hw"]
```

```bash
$ docker build -t go_hw:v1 .
$ docker run go_hw:v1
```

### Go internals

**1. Go compiler**

- Compiling source file and generate Object code.

```bash
$ go tool compile sourceFile.go
$ ls -ltr sourceFile.o  # This is not executable.
```

- Genereate an object file instaed of object code

```bash
$ go tool compile -pack sourceFile.go
$ ls -ltr sourceFile.a  
```

- The following will list the content of *.a file.

```bash
$ ar t sourceFile.a
__.PKGDEF
_go_.o

```

- To detect trace conditions

```bash
$ go tool compile -race sourceFile.a
```

- Showing assembly code

```bash
$ go tool compile -S sourceFile.go

os.(*File).close STEXT dupok nosplit size=26 args=0x18 locals=0x0
	0x0000 00000 (<autogenerated>:1)	TEXT	os.(*File).close(SB), DUPOK|NOSPLIT|ABIInternal, $0-24
	0x0000 00000 (<autogenerated>:1)	PCDATA	$0, $-2
	0x0000 00000 (<autogenerated>:1)	PCDATA	$1, $-2
	0x0000 00000 (<autogenerated>:1)	FUNCDATA	$0, gclocals·e6397a44f8e1b6e77d0f200b4fba5269(SB)
	0x0000 00000 (<autogenerated>:1)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0000 00000 (<autogenerated>:1)	FUNCDATA	$2, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)
	0x0000 00000 (<autogenerated>:1)	PCDATA	$0, $1
	0x0000 00000 (<autogenerated>:1)	PCDATA	$1, $1
	0x0000 00000 (<autogenerated>:1)	MOVQ	""..this+8(SP), AX
	0x0005 00005 (<autogenerated>:1)	MOVQ	(AX), AX
	0x0008 00008 (<autogenerated>:1)	PCDATA	$0, $0
	0x0008 00008 (<autogenerated>:1)	PCDATA	$1, $0
	0x0008 00008 (<autogenerated>:1)	MOVQ	AX, ""..this+8(SP)
	0x000d 00013 (<autogenerated>:1)	XORPS	X0, X0

...
```

**2. Garbage collector**

- Example of GC

```bash
package main
import (
    "fmt"
    "runtime"
    "time"
)
func printStats(mem runtime.MemStats) {
    runtime.ReadMemStats(&mem)
    fmt.Println("mem.Alloc:", mem.Alloc)
    fmt.Println("mem.TotalAlloc:", mem.TotalAlloc)
    fmt.Println("mem.HeapAlloc:", mem.HeapAlloc)
    fmt.Println("mem.NumGC:", mem.NumGC)
    fmt.Println("-----")
}

func main() {
    var mem runtime.MemStats
    printStats(mem)
    for i := 0; i < 10; i++ {
        s := make([]byte, 50000000) // memory allocation
        if s == nil {
            fmt.Println("Operation failed!")
        }
    }
    printStats(mem)
    for i := 0; i < 10; i++ {
        s := make([]byte, 100000000) // MORE memory allocation
        if s == nil {
            fmt.Println("Operation failed!")
        }
        time.Sleep(5 * time.Second)
    }
    printStats(mem)
}

```

```bash
$ go run gColl.go
```

- To get MORE information 

```bash
$ GODEBUG=gctrace=1 go run gColl.go

gc 1 @0.027s 0%: 0.048+0.72+0.007 ms clock, 0.38+0.18/0.62/1.1+0.057 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 2 @0.047s 0%: 0.006+0.56+0.007 ms clock, 0.055+0.39/0.69/0.79+0.061 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 3 @0.060s 1%: 0.16+1.0+0.011 ms clock, 1.2+1.3/1.1/0.13+0.093 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 4 @0.069s 1%: 0.016+0.54+0.016 ms clock, 0.13+0.16/0.61/1.0+0.12 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 5 @0.073s 1%: 0.002+0.37+0.003 ms clock, 0.023+0/0.37/1.0+0.028 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 6 @0.076s 1%: 0.016+0.41+0.011 ms clock, 0.13+0.14/0.60/0.40+0.088 ms cpu, 4->4->1 MB, 5 MB goal, 8 P
gc 7 @0.079s 1%: 0.002+0.34+0.010 ms clock, 0.020+0.14/0.36/0.82+0.081 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
# command-line-arguments
gc 1 @0.001s 10%: 0.002+1.3+0.011 ms clock, 0.018+0.82/1.4/2.0+0.092 ms cpu, 5->6->6 MB, 6 MB goal, 8 P
gc 2 @0.010s 7%: 0.004+3.4+0.011 ms clock, 0.036+0.42/5.3/3.8+0.090 ms cpu, 13->14->13 MB, 14 MB goal, 8 P
gc 3 @0.044s 4%: 0.017+4.8+0.011 ms clock, 0.13+0.18/8.2/18+0.093 ms cpu, 25->25->23 MB, 26 MB goal, 8 P
mem.Alloc: 125896

```

Taking the example of "4->4->0": 

        - The first number is the heap size when the garbage collector is about to run. 
        - The second value is the heap size when the garbage collector ends its operation. 
        - The last value is the size of the live heap

**3. GC internals**


**GC in slices**

**GC in maps**

**GC in maps without pointers**

**GC in spliting maps**

**GC comparisons`**

**GC unsafe code**

**GC unsafe package**

**Defer keyword**

**Defer keyword using logging**

**Panic**

**Recover**


**Strace**

**dtrace**

**Go environment**

**Node trees**

**Go build**

**WebAssembly code**


### Data types

**1. Slices**

- Slices are passed by reference to functions.

- Slices are often used, more than arrays.

```bash
 mySlcie := []int{1,23,4}
 mySlice := make([]int, 20)  // Go initilise with default values
 mySlice = append(mySlice, 2134)
 len(mySlice)
 fmt.Println(mySlice[1:3])
```

- Re-slicing may cause some problems.

Reslice do not copy values, reslice keeps reference from the orignal slice. Therefore, if you make any change of values in the reslice, they will also change values in the original slice.


```bash
package main
import "fmt"
func main() {
    s1 := make([]int, 5)
    reSlice := s1[1:3]  // Reslice not copy from s1, it make reference
    fmt.Println(s1)
    fmt.Println(reSlice)
    reSlice[0] = -100  // This means also s[1]=-100
    reSlice[1] = 123456 // This also means s[2]=123456
    fmt.Println(s1)
    fmt.Println(reSlice)
}

```

Output
```
$ go run reslice.go
[0 0 0 0 0]
[0 0]
[0 -100 123456 0 0]
[-100 123456]
```
- If the length and the capacity of a slice have the same values and you try to add another element to the slice, the capacity of the slice will be doubled whereas its length will be increased by one.

- Byte slices

```bash
s := make([]byte,5)


**2. Copy slices**

- Becareful using copy(destination, source), as copy() copies the minimum number of len(dst) and len(src) elements

**3. Sort slice**

**4. Appending arrays to slices** 


**5. Maps**

- Declaration

```bash
iMap = make(map[string]int)
delete(mapName, Key)

for key, value := range iMap {
    fmt.Println(key, value)
}

```

The bad thing is that if you try to get the value of a map key that does not exist in the map, you will end up getting zero, which gives you no way of determining whether the result was zero because the key you requested was not there or because the element with the corresponding key actually had a zero value. This is why we have _, ok in maps.

```bash

_, ok := iMap["doesItExist"]
if ok {
    fmt.Println("Exists!")
} else {
    fmt.Println("Does NOT exist")
}
```


Please note that you cannot and should not make any assumptions about the order the map pairs are going to be displayed on your screen because that order is totally random.

The next Go code will not work because you have assigned the nil value to the map you are trying to use:

```bash
aMap := map[string]int{}
// var aMap map[string]int
aMap = nil
fmt.Println(aMap)
aMap["test"] = 1
```

Saving the preceding code to failMap.go and trying to compile it will generate the next error message:
```bash
$ go run failMap.go
map[]
panic: assignment to entry in nil map
```
This means that trying to insert data to a nil map will fail. However, looking up, deleting, finding the length, and using range loops on nil maps will not crash your code.


**6. Constants**


**7. Pointers**

When working with pointers, you need * to get the value of a pointer, which is called dereferencing the pointer, and & to get the memory address of a non-pointer variable

```bash
package main
import (
    "fmt"
)
func getPointer(n *int) {
    *n = *n * *n

    fmt.Println(&n)
}
func returnPointer(n int) *int {
    v := n * n
    return &v
}
func main(){
    n:=3
    getPointer(&n)
    fmt.Println(n)

    k := returnPointer(12)
    fmt.Println(*k)
    fmt.Println(k)
}
```
Pointers allow you to share data, especially between Go functions. Pointers can be extremely useful when you want to differentiate between a zero value and a value that is not set

**Time**

```bash
package main
import (
    "fmt"
    "time"
)
func main(){
    fmt.Println(time.Now())
    time.Sleep(time.Second*2)
    t:=time.Now()
    fmt.Println(t.Day(),t.Month(), t.Year())
    t2:=time.Now()
    fmt.Println(t2.Sub(t))
    fmt.Println("time units", time.Nanosecond , time.Microsecond , time.Millisecond , time.Minute , time.Hour)
}
```

- Parsing date +time from a string:

| CODE | Meaning |
|------|---------|
| 2006 | Year |
| Jan | Month | 
| 02 | Day |
| 15 | Hour |
| 04 | Minute |
| 05 | Second |


```bash
package main
import (
    "fmt"
    "time"
)
func main(){
    test:="20201025 15:20:33"
    d,_:=time.Parse("20060102 15:04:05",test)
    fmt.Println(d.Hour(),d.Minute(),d.Second())
    fmt.Println(d.Year(),d.Month(),d.Day())
}
```

- Measure time execution

```bash
package main
import (
    "fmt"
    "time"
)
func main(){
    start:=time.Now()
    time.Sleep(time.Second)
    fmt.Println(time.Since(start))
}
```
### Composite Types

**1. Struct**

```bash
package main
import (
    "fmt"
)

type XY struct{
    x int
    y int
}

func returnPointer(x,y int) *XY {
    x++
    y++
    return &XY{x,y}
}
func returnStruct(x,y int) XY {
    x--
    y--
    return XY{x,y}
}
func main(){
    s1:=returnPointer(3,4)
    s2:=returnStruct(3,4)
    fmt.Println((*s1).x)  // You need a pointer reference in this case
    fmt.Println(s2.x)
}
```

**2. Tuples**

```bash
package main
import (
"fmt"
)
func retThree(x int) (int, int, int) {
return 2 * x, x * x, -x
}
func main() {
    fmt.Println(retThree(10))
    n1, n2, n3 := retThree(20)
    fmt.Println(n1, n2, n3)
    n1, n2, n3 =  n3,n2,n1  //swap
    fmt.Println(n1, n2, n3)
}



